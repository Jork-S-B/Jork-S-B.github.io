使用引用计数(Reference Counting)和垃圾回收(Garbage Collection)配合管理内存。

* 引用计数: 通过引用计数跟踪对象被引用的次数，当引用计数为0时，对象被销毁并立即回收相关内存。但当引用形成循环（如两个对象互相引用），引用计数无法解决。
* 垃圾回收: 专门处理引用循环的问题，使用“分代收集”机制，把对象按年龄分为三代：年轻代、中代、老年代。每一代有各自的垃圾收集频率，年轻代较快，老年代较慢。

当代码中使用外部C库，这些C库可能分配了程序的一些内存。Python在退出时不负责清理外部库分配的内存，需要依靠库本身提供的清理机制，否则可能发生内存泄漏。

## 📌 内存管理策略

* 使用`with open() as file:` 创建文件对象，Python会自动调用`file.close()`方法，确保文件被正确关闭。
* 尽量减少全局变量的使用
* 避免生成过多的短周期对象，及时清理不再需要的对象。
* 使用生成器(generator)代替列表以节省内存。
* 处理大量数据时，使用类似`numpy`或`pandas`的高效内存管理库。

## 📌 内存调试工具

objgraph 用于分析和绘制对象引用图，查看没有被正确回收的对象。

memory_profiler 用于监测脚本的内存使用情况。

tracemalloc 用于跟踪Python引用程序的内存分配情况。

gc 可以根据需求手动启动垃圾回收器。

valgrind 可用于检测C扩展中可能存在的内存泄漏。