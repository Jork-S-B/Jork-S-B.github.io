## 📌 分区

```sql
--查询表分区格式
SELECT PARTITION_NAME FROM USER_TAB_PARTITIONS WHERE TABLE_NAME = '{}';

--加分区, 用于分区的字段需要作为表主键
ALTER TABLE TABLE_NAME ADD PARTITION P202409 VALUES (202409);

--多个字段组合分区的表
ALTER TABLE TABLE_NAME SPLIT PARTITION P_0924_MAX AT (0924, 202409) INTO (PARTITION P_0924_202408, PARTITION P_0924_MAX) UPDATE GLOBAL INDEXES;
```

### 🚁 清分区数据

```sql
--hive无分区表的表
TRUNCATE TABLE TABLE_NAME;

--hive单个分区的表
ALTER TABLE TABLE_NAME DROP IF EXISTS PARTITION (month='202409');

--Oracle多个字段组合分区的表
ALTER TABLE TABLE_NAME TRUNCATE PARTITION P0924_202409 UPDATE INDEXES;
```

## 📌 同义词

```sql
--查建同义词的语句
SELECT DBMS_METADATA.GET_DDL('SYNONYM', 'SYNONYMNAME', 'USER') FROM DUAL;
--同理，可用来查建表语句
SELECT DBMS_METADATA.GET_DDL('TABLE', 'TABLE_NAME', 'USER') FROM DUAL;

--建同义词
CREATE OR REPLACE STNONYM USER1.SYNONYMNAME FOR USER2.TABLE_NAME;

--查所有同义词
SELECT * FROM DBA_SYNONYMS WHERE SYNONYM_NAME IN ('?');

--查表或视图或同义词各项信息，如创建时间
SELECT * FROM DBA_OBJECTS WHERE OBJECT_NAME = '?';
```

## 📌 序列

```sql
--查询序列的NEXTVAL
SELECT USER.SEQ_TABLE_NAME.NEXTVAL FROM DUAL;
--或者这种方式，需要先确定是哪个属主
SELECT T.LAST_NUMBER, T.* FROM USER_SEQUENCES T WHERE SEQUENCE_NAME LIKE '%SEQ_TABLE_NAME%';

--修改序列递增值
ALTER SEQUENCE SEQUENCE_NAME INCREMENT BY 100;

--建序列
DROP SEQUENCE USER.SEQUENCE_NAME;
CREATE SEQUENCE USER.SEQUENCE_NAME
	MINVALUE 100000000001
	MAXVALUE 999999999999
	START WITH 100000000001
	INCREMENT BY 1
	CACHE 2000;
```