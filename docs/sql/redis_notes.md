* 非关系型数据库，作为关系型数据库的补充，使用键值对存储数据。
* 降低磁盘IO，内存存储，支持持久化。
* 广泛用于缓存、消息队列、排行榜等场景。

什么样的数据适合使用Redis

* 鉴权后的token
* 时效性、高频访问的数据

## 📌 Redis常用指令

连接到远程Redis服务器：`./redis-cli -h ip -p port -a password`

|          指令           | 说明                 |
|:---------------------:|:-------------------|
|        keys *         | 查看所有的键             |
|        dbsize         | 键总数                |
|      exists key       | 检查键是否存在。存在：1，不存在：0 |
|        del key        | 删除键。删除成功：1，删除失败：0  |
|       type key        | 键的数据结构类型           |
|   rename key newkey   | 重命名键               |
|     set key value     | 设置值                |
|        get key        | 丨获取对应键的值           |
|        flushdb        | 清除当前数据库            |
|       flushall        | 清除所有数据库            |
|      info memory      | 查询内存使用情况           |
| CONFIG get maxclients | 查最大连接数             |

清除指定redis：`for i in $(seq 1001 1003)： do echo "flushab" | ./redis-cli -h ip -a password -p $i; done`

## 📌 Redis集群方案

* Sentinel-哨兵模式，基于主从，哨兵-集群监控、消息通知、故障转移、配置中心，不保证数据零丟失，只能保证高可用。
* Redis Cluster，数据分片存储在多个互为主从的多节点上，数据写入主节点，再同步到从节点，不保证强一致性。
* Redis Sharding

## 📌 性能指标

* Latency - redis响应一个请求的时间
* instantaneous_ops_pers_sec - 每秒处理请求数
* hi rate(calculated) - 缓存命中率

### 🚁 缓存击穿

指**某个**热点数据在缓存中过期的瞬间，大量并发请求直接穿透到数据库，可能导致数据库压力骤增甚至崩溃。

常见原因: 

1. 业务代码或数据有问题。
2. 恶意攻击、爬虫等造成大量空命中。

解决方案: 

1. 永不过期策略
2. 错峰过期
3. 逻辑过期时间：当数据过期时，异步更新数据而不阻塞请求。
4. 使用布隆过滤器快速判断数据是否存在，避免无效请求穿透到数据库。
5. 加互斥锁：当缓存失效时，只允许一个线程去加载数据，其他线程等待。
6. 缓存预热：在系统启动或低峰期预先加载热点数据到缓存。

### 🚁 缓存雪崩

指在某个时间段内，**大量**的缓存同时失效或者Redis服务宕机后恢复，导致所有请求都直接访问数据库，从而引发数据库连接或性能瓶颈，甚至宕机。

常见原因: 

1. 集中过期：设置了相同的过期时间，导致大量缓存同时失效。
2. Redis宕机：Redis服务异常或网络中断，导致所有缓存不可用。
3. 缓存层故障转移失败：如集群部署时节点宕机未及时恢复。

解决方案: 

1. 上述缓存击穿的解决方案
2. 熔断限流（服务降级），在访问数据库前加入熔断机制，当请求超过阈值时直接返回错误或默认值，防止数据库被压垮。
3. 缓存高可用架构（主从、集群）
4. 多级缓存架构（本地缓存+redis缓存）

---

